# Пример повторной обработки сообщений Kafka по времени

Этот пример демонстрирует механизм повторной обработки (retry) сообщений Kafka на основе временных меток, а не смещений (offsets). Такой подход полезен, когда мы не знаем, какой offset был в определенное время, или когда нам нужно отложить обработку сообщения на будущее.

## Описание

В данном примере реализована следующая схема работы:

1. **Продюсер** отправляет сообщения с метками времени (`process_at`), указывающими, когда сообщение должно быть обработано.
2. **Основной консьюмер** проверяет время обработки каждого сообщения:
   - Если время обработки еще не наступило, сообщение перемещается в топик повторной обработки.
   - Если время обработки наступило, сообщение обрабатывается.
   - В случае ошибки обработки, сообщение отправляется в топик повторной обработки с увеличенным счетчиком попыток и новым временем обработки.
3. **Консьюмер повторной обработки** проверяет сообщения из топика повторной обработки и перемещает их обратно в основной топик, когда наступает время их обработки.

## Файлы примера

- **producer.php** - отправляет сообщения в Kafka с метками времени обработки
- **consumer.php** - обрабатывает сообщения из основного топика с учетом времени обработки
- **retry-consumer.php** - обрабатывает сообщения из топика повторной обработки
- **create-topics.sh** - скрипт для создания необходимых топиков

## Структура сообщения

Каждое сообщение имеет следующую структуру:

```json
{
  "id": "уникальный_идентификатор",
  "message": "текст_сообщения",
  "created_at": 1620000000,  // Unix timestamp создания сообщения
  "process_at": 1620001000,  // Unix timestamp, когда сообщение должно быть обработано
  "retry_count": 0           // Счетчик попыток обработки
}
```

## Механизм повторной обработки

1. При неудачной обработке сообщения увеличивается счетчик попыток (`retry_count`).
2. Новое время обработки вычисляется с использованием экспоненциальной задержки: `30 * 2^(retry_count-1)` секунд.
3. Сообщение с обновленными данными отправляется в топик повторной обработки.
4. Консьюмер повторной обработки периодически проверяет сообщения и возвращает их в основной топик, когда наступает время обработки.
5. После достижения максимального количества попыток (по умолчанию 3), сообщение отбрасывается.

## Преимущества подхода

1. **Отложенная обработка** - возможность запланировать обработку сообщения на определенное время.
2. **Независимость от смещений** - механизм работает на основе времени, а не смещений Kafka.
3. **Экспоненциальная задержка** - увеличение интервала между попытками снижает нагрузку на систему.
4. **Устойчивость к сбоям** - даже при перезапуске консьюмеров, время обработки сохраняется в самом сообщении.

## Подготовка

Перед запуском примера необходимо создать топики:

```bash
# Создание топиков
./create-topics.sh
```

## Запуск примера

### Запуск продюсера
```bash
docker exec -it kafka_examples_php php /var/www/html/examples/retry-by-time/producer.php
```

### Запуск основного консьюмера
```bash
docker exec -it kafka_examples_php php /var/www/html/examples/retry-by-time/consumer.php
```

### Запуск консьюмера повторной обработки
```bash
docker exec -it kafka_examples_php php /var/www/html/examples/retry-by-time/retry-consumer.php
```

## Практические рекомендации

1. В продакшн-системах рекомендуется использовать отдельные топики для разных уровней повторной обработки (например, retry-1min, retry-5min, retry-30min).
2. Для критически важных сообщений, которые не могут быть потеряны, следует добавить механизм Dead Letter Queue (DLQ).
3. Время обработки можно вычислять различными способами в зависимости от бизнес-требований (фиксированные интервалы, экспоненциальная задержка, случайная задержка).
4. Для более сложных сценариев можно добавить приоритеты сообщений, которые будут влиять на порядок обработки.

## Сравнение с другими примерами

- **basic** - простой пример работы с Kafka без механизма повторной обработки
- **advanced** - продвинутый пример с использованием ООП-подхода
- **partitioned** - пример с явным назначением партиций
- **lowlevel** - пример с использованием низкоуровневого API
- **retry-by-time** (этот пример) - пример с механизмом повторной обработки на основе времени
